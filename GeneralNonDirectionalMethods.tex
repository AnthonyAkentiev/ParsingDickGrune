\chapter{Основные ненаправленные методы разбора}
%\label{Chapter4}
%стр 81 оригинала

В этой главе мы рассмотрим два ненаправленных метода: метод Ангера\footnote{Unger - \textit{Прим.пер.}} и CYK. \\
Эти методы названы ненаправленными, так как они могут абсолютно произвольно обращаться к исходной строке. Они требуют, чтобы вся входная строка находилась в памяти перед тем, как начнётся разбор. 

Метод Ангера является нисходящим. Если исходная строка принадлежит языку, то она должна выводиться из начального символа грамматики. Следовательно, она должна выводиться из правой части продукции, допустим ${A_1A_2 \cdots A_m}$. В свою очередь это означает, что $A_1$ должен выводить первую часть ввода, $A_2$ вторую, итд. Если на вход поступило предложение $z_1z_2 \cdots z_n$, то это можно изобразить так:

Метод Ангера пытается разделить исходную строку. Эта задача является рекурсивной: если нетерминал $A_i$ соответсвует какой-либо части строки, то должно, в свою очередь, существовать такое разделение уже этой части, которое выводится из правой стороны продукции $A_i$. В итоге, правая часть должна включать только терминалы. Их можно легко сопоставить с текущей частью ввода.
	Метод CYK подходит к задаче с другой стороны: он пытается отыскать правые части продукций в исходной строке; каждый раз, когда такие части встречаются, делается вывод, что они порождаются из левой стороны продукции. В этих сентенциальных формах снова проводится процесс нахождения правой части продукций.  						 %^^^sententional form?
В результате, мы найдем такую сентенциальню форму, которая будет порождать входную строку,а также являться правой частью начального символа (нетерминала).\\
В двух следующих главах эти методы рассматриваются подробнее.\\
%след:
\section{Метод разбора Ангера}
Входом для метода Ангера является КС грамматика и, непосредственно, входная строка. Для начала, мы рассмотрим метод разбора Ангера для грамматик без $\varepsilon$-правил и без циклов. После, мы изменим метод так, чтобы он удовлетворял всем КС грамматикам. 

\subsection{Метод Ангера без $\varepsilon$-правил и циклов}
%\label{sec:МетодАнгераБезEПравилИЦиклов}
Чтобы понять, как метод Ангера решает проблему разбора, давайте рассмотрим простой пример. Представьте, что мы имеем такую грамматику:
$$S\rightarrow ABC |DE|F$$
Необходимо определить, выводит ли S введённую строку \textit{pqrs}. Начальная задача разбора может быть изображена так:
%рисунок
Для каждой правой части мы должны сгенерировать все возможные разделения введённой строки. Это не так сложно: если у нас есть \textit{m} ящиков (пронумерованных от 1 до \textit{m}) и \textit{n} деталей (пронумерованных от 1 до \textit{n}), то мы должны отыскать все возможные варианты, при которых выполняются условия "`каждый ящик содержит хотя бы одну деталь"', "`детали в каждом ящике упорядочены"',а также "`любой ящик не содержит деталь с меньшим номером, чем любая деталь в ящиках с меньшим номером"'. 
%разложение или распределение?
Мы поступим так: сначала, мы положим деталь 1 в ящик 1, а потом разложим оставшиеся \textit{n}-1 детали по \textit{m}-1 ящикам. Это даст нам все разложения, в которых деталь 1 находится в первом ящике. Затем мы кладём детали 1 и 2 в первый ящик, раскладываем остальные \textit{n}-2 детали по \textit{m}-1 ящикам, итд. Если \textit{n} меньше \textit{m}, то разложение невозможно.
\paragraph{}Разделение введённой строки походит на распределение деталей (введённых символов) по ящикам (правые части продукций). Если правая часть имеет больше символов, чем предложение, разделение невозможно(не забывайте о запрете $\varepsilon$-правил). Для начальной правой части должно получиться следующее разделение: 
%рисунок
Из первого разделения вытекают следующие вопросы: выводится ли \textit{p} из \textit{A }, выводится ли \textit{q} из \textit{B}, и выводится ли \textit{rs} из \textit{C}? На все эти нужно ответить утвердительно, либо такое разделение невозможно.
\paragraph{}Для второй правой части продукции, мы получим следующие разделения:\\\\
%рисунок
Последняя правая часть образует следующее разделение:
%рисунок
Все разделения, кроме последнего, имеют дело с меньшими, по сравнению с исходной, строками. Они все приведут к таким же разделениям, и многие из них не смогут "`завершиться"', т.к. правая часть продукции не будет отвечать соответствующей части разделения. Лишь последнее разделение заслуживает особого внимания. Оно очень похоже на то, с которого мы начинали. По этой причине мы запретили циклы в грамматике. Если грамматика имеет цикл, мы будем возвращаться к началу снова и снова. Допустим, если существует продукция $F\rightarrow S$ для приведённой выше грамматики, то возникнет такая ситуация.\\
	Все вышележащее показывает, что у нас в наличии поисковая задача, и мы должны решить её поиском в-глубину или поиском в-ширину (см 3.6.2). Ангер применяет поиск в глубину.\\
	Для дальнейшего рассмотрения примером будет служить грамматика, приведённая на рис.4.1.
%рисунок
Эта грамматика описывает язык простейших арифметических выражений с операторами + и $\times$, а также с операндом \textbf{i}. В качестве ввода будем использовать предложение $\left(\textbf{i}+\textbf{i}\right)\times \textbf{i}$, так что задача будет иметь вид:\\
%рисунок
Процесс разделения введённой строки на основе правой части первой продукции \textbf{Expr}:\\
%рисунок
Даже такой небольшой пример даёт в результате 15 разделений, но мы не будем проверять их все, так как даже неоптимизированная версия алгоритма действует так. Мы только проверим разделения, которые могут успешно завершиться: можно отбросить все разделения, которые не подходят терминалу из правой стороны. Поэтому, вот единственное разделение, стоящее внимания:\\
%рисунок
Первой подзадачей является определение возможности вывода (и каким образом) $(\textbf{i}$ из \textbf{Expr}. Мы не можем разделить подстроку $(\textbf{i}$ на три непустые части, т.к. она состоит только из двух символов. Поэтому, единственное правило, которое мы можем применить, это $\textbf{Expr}\rightarrow \textbf{Term}$. Точно также, следующим употреблённым правилом может быть только $\textbf{Expr}\rightarrow \textbf{Factor}$. Теперь мы имеем:\\
%рисунок
	Тем не менее, такое невозможно, так как первая правая часть \textbf{Factor} имеет слишком много символов, а вторая состоит лишь из одного. Из этого следует, что разделение, с которого мы начали, не подходит и должно быть отвергнуто. Другие способы разделения уже были отвергнуты, поэтому мы можем заключить, что $\textbf{Expr}\rightarrow \textbf{Expr} + \textbf{Term}$ не может произвести введённую строку. \\
	Вторая правая часть \textbf{Expr} состоит только из одного символа, поэтому существует лишь одно разделение, состоящее из одной части. Разделение этой части согласно первой правой части \textbf{Term} опять приводит к 15 различным вариантам, из которых, снова, лишь один может привести к успеху:
%рисунок p85
Продолжая наш поиск, мы найдём следующее разделение:

\begin{figure}[h]
\HSp
\begin{tabular}{lcl}
\label{p85none}
%\begin{center}
%\hspace{3.5cm}
\GrT{$Expr$} & $\rightarrow$\\
\GrT{$Term$} & $\rightarrow$\\
\GrT{$Term \times Factor$} & $\rightarrow$\\
\GrT{$Factor \times Factor$} & $\rightarrow$\\
\GrT{$( Expr ) \times Factor$} & $\rightarrow$\\
\GrT{$( Expr + Term ) \times Factor$} & $\rightarrow$\\
\GrT{$( Term + Term ) \times Factor$} & $\rightarrow$\\
\GrT{$( Factor + Term ) \times Factor$} & $\rightarrow$\\
\GrT{$( i + Term ) \times Factor$} & $\rightarrow$\\
\GrT{$( i + Factor ) \times Factor$} & $\rightarrow$\\
\GrT{$( i + i ) \times Factor$} & $\rightarrow$\\
\GrT{$( i + i ) \times i$}
%\end{center}
\end{tabular}
\end{figure}
и это единственное найденное разделение.\\
	Этот пример осветил некоторые из аспектов метода: даже небольшой пример требует существенного количества времени, но простейшие улучшения(проверки условий) могут принести огромную пользу. Так, сопоставление терминала в правой части продукции с разделением обычно ведёт к отбрасыванию этого разделения без дальнейшего его рассмотрения. Ангер приводит ещё несколько улучшений. Например, можно подсчитать длину строк терминальных символов, выводимых из каждого нетерминала. Как только нам становится известен определённый нетерминал, который выводит только строки из хотя бы \textit{n} символов, все разделения, сопоставляющие этому нетерминалу строки с длиной меньше \textit{n} символов, могут быть отброшены.\\
	
\subsection{Метод Ангера с $\varepsilon$-правилами}
До сих пор мы имели дело лишь с грамматиками без $\varepsilon$-правил, и не беспочвенно. Алгоритм заметно усложняется, если грамматика имеет $\varepsilon$-правила. Это показано на следующем примере: пусть мы имеем правило $S\rightarrow ABC$ и входную строку \textit{pqr}. Если мы желаем проверить, выводит ли это правило входную последовательность, и $\varepsilon$-правила разрешены, гораздо большее количество разделений должны быть проверены, т.к. каждый нетрминал $A$, $B$, $C$ могжет вывести пустые строки. В этому случае, генерация всех разделений происходит точно так же, как и выше, за исключением того, что сначала рассматриваются распределения вообще без деталей в первом ящике. Затем: разделения с деталью №1 в первом ящике, итд.\\
%p86
%13.04.06
%рисунок
Теперь представьте, что мы должны проверить, выводится ли \textit{pqr} из $B$. Представьте также, что у нас есть правило $B\rightarrow SD$. Мы должны проверить следующие разделения:\\
%рисунок
Последнее разделение вызовет затруднения: в процессе поиска мы опять вернёмся к началу, но, правда, в уже в другом контексте. Если мы не остановим этого, наш разборщик войдет в бесконечный цикл (или исчерпает всю памяти).\\
%???? проверить next paragraph:
	Мы должны быть внимательны с продукциями, которые имеют цикл. Он может существовать, даже если грамматика не имеет (явного) цикла. Если такой цикл присутствует в грамматике, то существует бесконечное множетсво выводов, поэтому мы никогда не сможет перебрать (представить) их все. Единственные продукции, которые мы не должны исследовать - те, что содержат циклы, поэтому мы будем отбрасывать их. Но, если грамматика не имеет циклов, то такое отбрасывание никак не повлияет на работу алгоритма. К счастью, отбрасывание - не такая трудная задача. Все, что мы должны сделать, это хранить набор (например, в виде списка) вопросов, которые мы рассматриваем в данный момент. Перед началом исследования очередного вопроса (например, "`выводится ли \textit{pqr} из \textit{S}"') мы сначала проверяем его наличие в списке. Если он уже включен туда, мы отбрасываем его. Мы продолжаем так, как будто получили негативный ответ на вопрос.\\
	Представьте для примера следующую грамматику:\\
%рисунок
Эта грамматика порождает последовательность из символов \textbf{d} странным образом. Полноценный поиск ответов на вопросы $S\stackrel{*}{\rightarrow} d?$ и $S\stackrel{*}{\rightarrow} dd?$ показан на рис. 4.2:\\
%большой рисунок p87
%проверить: слева направо?
Рисунок 4.2 должен рассматриваться слева направо и сверху вниз. Вопросы изображены в эллипсах, а разветвления правых частей - в прямоугольниках. Если хотя бы один прямоугольник (идущий от какого-либо эллипса с вопросом) приводит к результату ""'Да"', значит мы получили положительный ответ. В противоположность этому, разделение завершается успешно, лишь если все вопросы, выдвинутые им, приводят к ответу "`Да"'.\\
	Проверка на отбрасывание проста: если поставлен новый вопрос, мы следуем по стрелкам в обратном направлении (налево). Так, мы проходим список текущих рассматриваемых вопросов. Если мы встречаем вопрос снова, мы должны прервать поиск (произвести отбрасывание).\\% ??? cut-off
	Чтобы разобрать строку, каждый положительный ответ должен возвращать обратно список правил, которые начинают продукцию, используемую в этом вопросе. Этот список можно также отображать в эллипсе вместе с вопросом. Мы не поступили так на рис. 4.2, потому как он и так достаточно запутан. Тем не менее, если мы освободим рис. 4.2 от "`тупиков"' и уберём прямоугольники, то получим картину, показанную на рис. 4.3:\\
%большой рисунок p88
%14.04.06
В этом случае, каждый эллипс включает лишь одно грамматическое правило. Поэтому, существует только один разбор, и мы получаем его чтением рис. 4.3 слева направо, сверху вниз:
$$S\rightarrow LSD \rightarrow SD \rightarrow LSDD \rightarrow SDD \rightarrow DD \rightarrow dD \rightarrow dd$$
Вообще, полное количество разборов равно произведению правил в каждом эллипсе.\\
	Этот пример показывает, что мы можем сохранить много времени запоминанием ответов на вопросы. Допустим, вопрос "`Выводится ли $\varepsilon$ из $L$?"' задаётся несколько раз. Шейл\footnote{Sheil - Прим.пер.} показал, что эффективность сильно возрастает когда применяется такое "`запоминание"': время работы уменьшается от экспоненциального к полиноминальному. Другая возможная оптимизация достигается заблаговременным определением, какой нетерминал может вывести $\varepsilon$. По сути, это особый способ нахождения минимальной длины терминальной строки, которую может вывести каждый нетерминал. Если нетерминал выводит $\varepsilon$ - длина этой строки равна нулю.
\section{Метод разбора CYK}
%раздел ли?
Метод разбора, рассматриваемый в этом разделе, приписывают Дж.Коку, Д.Г.Йангеру и Т.Касами, которые, независимо разработали различные варианты этого способа. Сейчас он более известен как метод Кока-Йангера-Касами\footnote{Cocke-Younger-Kasami - Прим.пер.}, или сокращенно - CYK. Наиболее доступное оригинальное описание находится в книге Йангера <>. Намного более раннее описание можно найти в <>.\\
	Также как и в методе Ангера, на вход алгоритма поступает КС грамматика и входная строка. Первая часть алгоритма состоит из построения таблицы, показывающей, какой нетерминал выводит какую подстроку из входной последовательности. Этот этап носит название "`обнаружение"'\footnote{recognition - Прим.пер}. Второй этап, используя полученную на первом шаге таблицу, а также грамматику, строит все возможные выводы для 
%(необходимые для генерации)
исходной строки.\\
	Сначала мы заострим своё внимание на фазе обнаружения, которая, на самом деле, является характерной особенностью данного алгоритма.
\subsection{CYK разбор с основными КС грамматиками}
Чтобы понять, как CYK справляется с проблемами обнаружения и разбора вообще, рассмотрим пример с рис. 4.4. Эта грамматика описывает
%scientific?
научную запись чисел. Давайте, для примера, на ввод подадим предложение $32.5e+1$.\\
\begin{figure}[h]
\HSp
\begin{tabular}{lcl}
\label{fig44}
%\begin{center}
%\hspace{3.5cm}
\GrT{$Number_S$} & $\rightarrow$ & $Integer | Real$\\
\GrT{$Integer$} & $\rightarrow$ & $Digit | Integer Digit$\\
\GrT{$Real$} & $\rightarrow$ & $Integer Fraction Scale$\\
\GrT{$Fraction$} & $\rightarrow$ & $. Integer$\\
\GrT{$Scale$} & $\rightarrow$ &  $e Sign Integer | Empty$\\
\GrT{$Digit$} &  $\rightarrow$ & $0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9$\\
\GrT{$Empty$} & $\rightarrow$ &  $\varepsilon$\\
\GrT{$Sign$} & $\rightarrow$ & $+ | -$\\
%\end{center}
\end{tabular}
\caption{Грамматика, описывающая число в научной записи}
\end{figure}

Алгоритм CYK сначала фокусируется на подстроках введённой последовательности, начиная с самой короткой, а затем идёт вверх. Следующие выводы подстрок длинны 1 могут быть прочитаны прямо из грамматики:\\
%рис стр.89
Это означает, что \textbf{Digit} выводит \textbf{3}, \textbf{Digit} выводит \textbf{2}, итд. Обратите внимание, что эта картина ещё не закончена из-за того, что другие нетерминалы также выводят \textbf{3}. Эта сложность возникает, т.к. грамматика содержит так называемые \textit{цепные правила}\footnote{unit rules - Прим.пер.} - правила вида $A \rightarrow B$, где $A$ и $B$ нетерминальные символы. Такие правила ещё называют \textit{едиными} или \textit{последовательными}. Мы можем иметь такие цепочки в продукции. Поэтому, следующий шаг заключается в последовательном применении цепных правил, например, для выяснения, какой ещё нетерминал выводит \textbf{3}. Это даёт следующий результат:\\
%рис
%стр90
Теперь, мы ясно видим несколько комбинаций, которые мы обнаружили в грамматике: например, \textbf{Integer} за которым следует \textbf{Digit}, это опять \textbf{Integer}. Точка, за которой следует \textbf{Integer} это \textbf{Fraction}. Мы получаем (опять применяя цепные правила):\\
%рис
На данный момент, мы заметили, что \textbf{Real}-правило применялось различными способами, а за ним следовало \textbf{Number}-правило. Поэтому:\\
%рис
Мы убедились, что \textbf{Number} действительно выводит $32.5e+1$.\\
	Из этого примера понятно, что цепные правила добавлют лишней сложности. Другая сложность, которую мы до сих пор избегали, это $\varepsilon$-правила. Например, если мы желаем разобрать $43.1$, используя ту же грамматику, мы встречаем $\varepsilon$ при выводе из \textbf{Scale}:\\
%рис
Вообще, этот пример даже сложнее. Мы должны помнить, что различные нетерминалы могут выводить $\varepsilon$ между любыми двумя смежными терминальными символами во входной последовательности, а также в её начале или конце. Тем не менее, как мы вскоре убедимся, проблемы, вызванные  правилами такого типа, могут быть решены 
%albeit at a certain cost:
определённой ценой.\\
	В то же время, мы не позволим этой проблеме доставлять нам дискомфорт. В этом примере мы увидели, что CYK алгоритм определяет, какой нетерминал выводит данную подстроку, начиная с самых коротких. Но мы пропустили самые короткие из них. Конечно же это $\varepsilon$-подстроки. Мы должны иметь возможность распознать их в любой позиции, поэтому давайте сначала убедимся, что можем найти $R_\varepsilon$, множество всех нетерминалов, выводящих $\varepsilon$.\\
%вопрос в запятой между 'нетерминалов выводящих'

%15.04.06 p91
	Изначально, это множество состоит из нетерминалов $A$, для котрых существует правило $A\rightarrow \varepsilon$. Для грамматики из нашего примера, $R_\varepsilon$, это множество $\left\{ Empty \right\}$. Далее, мы проверим каждое правило грамматики: если правая часть содержит только символы, не имеющиеся в $R_\varepsilon$, то мы добавим левую часть продукции в $R_\varepsilon$ (она выводит $\varepsilon$ т.к. все символы в правой части выводят $\varepsilon$). К примеру, таким символом будет $Scale$. Этот процесс повторяется до тех пор, пока в множество $R_\varepsilon$ не могут быть добавлены какие-либо новые нетерминалы. Для нашего случая:\\
%рис
Теперь мы обратим своё внимание на нетерминальные подстроки входной последовательности. Представьте, что мы имеем на входе предложение $z=z_1z_2\cdots z_n$, и нам нужно найти множество всех нетерминалов, выводящих подстроки длины \textit{l} из \textit{z}, начиная с позиции \textit{i}. Мы будем использовать обозначение $s_{i,l}$ для таких подстрок:\\
$$z=z_1z_2\cdots z_{i+l-1}$$
На рис. 4.5 изображена такая запись (предложение состоит из 4 символов) в графическом виде.
%рис 4.5.
Мы будем использовать обозначение $R_{s_{i,l}}$ для множества нетерминалов выводящих подстроку $s_{i,l}$. Такое обозначение может быть использовано и для строк нулевой длины: $s_{i,0}=\varepsilon$ и $R_{s_{i,0}} = R_\varepsilon$\\
%запятая между таких чтобы? :
	Так как более короткие строки рассматриваются в первую очередь, мы можем предположить, что владеем всей информацией о подстроках с длиной меньше определённого числа \textit{l}. Использую эту информацию, мы проверим правую часть всех продукций в грамматике, чтобы узнать, выводит ли она $s_{i,l}$. Поступим следующим образом: представим, что имеем правую часть $A_1\cdots A_m$. Разделим $s_{i,l}$ на \textit{m} (возможно пустых) сегментов, таких, чтобы $A_1$ выводил первый сегмент, $A_2$ второй, итд. Начнём с $A_1$. Если $A_1\cdots A_m$ выводит $s_{i,l}$, значит $A_1$ должен выводить её первую часть, допустим длины \textit{k}. Т.е. $A_1$ должен выводить $s_{i,k}$ (входит в $R_{s_{i,k}}$), а $A_2\cdots A_m$ должны выводить всё остальное.\\
%рис стр.92
Мы пробуем любое число \textit{k}, при котором $A_1$ является членом множества $R_{s_{i,k}}$, включая нуль. Если $A_1$ терминал, то $A_1$ должен быть равен $z_i$, а \textit{k} равно еденице. Проверка, выводится ли $z_{i+k}\cdots z_{i+l-1}$ из $A_2\cdots A_m$ выполняется точно также. В отличие от метода Ангера, мы не должны проверять все возможные разделения, т.к. мы заранее знаем, какой нетерминал выводит какие строки.\\
	Тем не менее, существует несколько проблем, связанных с этим: во-первых, число \textit{m} может быть равно 1, а $A_1$ может быть нетерминалом, так что мы имеем цепное правило. В 
этом случае, $A_1$ должен выводить всю строку $s_{i,l}$, и быть поэтому членом множества $R_{s_{i,l}}$, которое мы в данный момент только находим (соответственно, мы не знаем об этом). Эта проблема может быть решена проверкой: если $A_1$ выводит $s_{i,l}$, то, при выводе, должен существовать шаг без использования цепных правил. Далее:\\
$$A_1 \rightarrow B \rightarrow \cdots \rightarrow C \stackrel{*}{\rightarrow} s_{i,l}$$
\textit{С} является первым нетерминалом, не использующий цепное правило. Не принимая во внимание $\varepsilon$-правила (вторая проблема), это означает, что на каком-то этапе, \textit{С} будет добавлен в $R_{s_{i,l}}$. Теперь, повторяя процесс снова и снова, будет добавлен \textit{B}, а на следующем повторе - $A_1$. Будем повторять процесс до тех пор, пока в $R_{s_{i,l}}$ не будет добавляться новых нетерминалов. Вторая проблема вызвана $\varepsilon$-правилами. Если хотя бы одно из $A_t$ выводит $\varepsilon$, мы встречаем сложность, очень схожую с цепными правилами. Она может быть решена так же.\\
	В результате, когда мы получим полноценное $R_{s_{i,l}}$, проблема обнаружения будет решена: начальный символ \textit{S} выводит \textit{z} (= $S_{1,n}$) тогда и только тогда, когда \textit{S} является членом $R_{s_{1,n}}$.\\
	Это запутанный процесс, но часть сложности исходит от $\varepsilon$-правил и цепных правил. Их существование заставляет нас работать с $R_{s_{i,l}}$ последовательно. Другой, менее серьёзный, источник усложнения заключается в том, что правая часть может иметь произвольно большое число нетерминалов. Проверка всех вариантов затянется надолго. Если мы обойдем эти гораничения, то сильно упростим процесс. Тем не менее, эти ухищрения не должны сильно уменьшить описательные возможности грамматики.\\
%ХНФ ???
\subsection{CYK-распознавание с грамматикой в CNF}
Два ограничения, которые мы желаем обойти, прозрачны для нас: никаких цепных правил и $\varepsilon$. Мы одновременно хотим ограничить максимальну длину правой части двумя символами. Это упростит проверки на вывод конкретной подстроки. Эти требования приводят нас к подтипу КС-грамматик, которые удовлетвояют им: Нормальная Форма Хомского\footnote{Chomsky Normal Form (CNF) - Прим.пер.}. Может показаться, что эта форма была разработана специально для нашего алгоритма. Грамматика находится в CNF, если все правила имеют вид $A\rightarrow a$ или $A\rightarrow BC$, где \textit{a} это терминал, а \textit{A},\textit{B},\textit{C} нетерминалы. К счастью, как мы увидим далее, практичеси любая КС грамматика может быть преобразована к CNF.\\
	Сначала мы обсудим как CYK алгоритм работает с грамматикой в CNF.\\
%стр 93
В CNF нет $\varepsilon$-правил, поэтому множество $R_\varepsilon$ является пустым. Множества $R_{s_{i,1}}$ можно легко получить из правил: они определяются продукциями вида $A\rightarrow a$. Правила $A\rightarrow BC$ никогда не выведут одиночный терминал, т.к. мы запретили $\varepsilon$-правила.\\
	Давайте итеративно продолжим так же, как и до этого, обрабатывая сначала все подстроки с длиной 2, затем все подстроки длины 3, итд. Когда правая часть \textit{BC} должна вывести подстроку длиной \textit{l}, то \textit{B} должен вывести первую часть (которая непуста), а \textit{C} должен вывести остальное (также не пусты).\\
%рис
	То есть \textit{В} должен выводить $s_{i,k}$,а это означает, что \textit{В} должен быть членом $R_{s_{i,k}}$, и, точно так же, \textit{С} должен выводить $s_{i+k,l-k}$, \textit{С} должен быть членом $R_{s_{i+k,l-k}}$. Определить, существует ли такое \textit{k} очень легко: нужно просто попробовать все возможные варианты (от 1 до \textit{l}-1). Все множества $R_{s_{i,k}}$ и $R_{s_{i+k,l-k}}$ к этому моменту уже полностью найдены.\\
	Этот процесс гораздо проще того, что применялся для обычной КС грамматики. Это объясняется двумя причинами. Первая, и самая глвная, заключается в том, что теперь мы не должны повторять процесс снова и снова до тех пор, пока в $R_{s_{i,l}}$ не будут добавляться новые нетерминалы. Теперь подстроки, с которыми мы имеем дело, являются действительно подстроками. Они не могут быть равны начальной строке. Вторая причина улучшения: мы должны найти единственное место разделения подстроки, т.к. правая сторона содержит лишь два нетерминала. В неоднозначных грамматиках существует несколько возможных разделений, но на данный момент нас это не должно волновать. Неоднозначность - проблема разбора, а не обнаружения.\\
	Алгоритм приводит к полному набору множеств $R_{s_{i,l}}$. Предложение \textit{z} содержит всего \textit{n} символов, поэтому подстрока, начинающаяся с позиции \textit{i} не может иметь более \textit{n+1-i} символов. Это означает, что не существует подстроки $s_{i,l}$ у которой \textit{i+1>n+1}. Поэтому,  $R_{s_{i,l}}$ можно представить в виде треугольной таблицы, как показано на рис. 4.6.\\
%рис
%!!! распознавания...
Эта таблица называется \textit{таблицей обнаружения}, \textit{таблицей правильных построений} либо \textit{таблицей распознавания}. $R_{s_{i,l}}$ формируется следующим образом: двигаясь одновременно по направлениям, указанным стрелками \textit{V} и \textit{W}, находим правила вида $A\rightarrow BC$, где \textit{B} является членом множества по стрелке \textit{V}, а \textit{C} соответственно - членом множества по стрелке \textit{W}. Подстроки для \textit{В} берутся начиная с позиции \textit{i}, с увеличивающейся длиной \textit{k}. Поэтому стрелка \textit{V} указывает вертикально вверх на $R_{s_{i,1}}, R_{s_{i,2}}\cdots , R_{s_{i,k}},\cdots ,R_{s_{i,l-1}}$. Для \textit{C} подстроки формируются начиная с позиции \textit{i+k}, с длиной \textit{l-k} и конечной позицией \textit{i+l-1}, поэтому стрелка \textit{W} направлена диагонально вниз, указывая (посещая) $R_{s_{i+1,l-1}}, R_{s_{i+2,l-2}}\cdots , R_{s_{i+k,l-k}},\cdots ,R_{s_{i+l-1,1}}$.\\
%16.04.06 стр 94
	Как описано выше, таблица обнаружения вычисляется в порядке, указанном на рис. 4.7(а). Мы также можем вычислить таблицу обнаружения в порядке, указанном на рис.4.7(б). В последнем случае, $R_{s_{i,l}}$ вычисляется как только все необходимые множества и входные символы становятся доступны. Например, при вычислении $R_{s_{3,3}}$, $R_{s_{5,l}}$ релевантно, а $R_{s_{6,l}}$ нет, т.к. подстрока в позиции 3 и с длиной 3 не содержит подстроку в позиции 6 и с длиной 1. Такой порядок даёт возможность приименения алгоритма для оперативного разбора, где число входных символов неизвестно заранее, а вычисления происходят при каждом вводе нового символа.\\
%рис 4.7. а и б
Теперь давайте рассмотрим стоимость этого алгоритма. Из рис. 4.6 видно, что нужно проверить $(n*(n+1))/2$ подстрок. Для каждой подстроки, нужно проверить максимум $n-1$ различных \textit{k}-разделений.	Все остальные операции не зависят от \textit{n}, так что алгоритм работает за время, пропорциональное кубу длины входной последовательности. Поэтому, он гораздо более эффективен, чем простой поиск, который требует экспоненциального количества времени.\\

\subsection{Преобразование КС грамматики в CNF}
Предыдущая глава показала, что однозначно стоит переводить КС грамматику в CNF. Далее обсуждается такое преобразование на примере нашей "`численной"' грамматики. Преобразование делится на несколько стадий:
\begin{itemize}
	\item Избавление от $\varepsilon$-правил
	\item Избавление от цепных правил
	\item Избавление от непроизводящих нетерминалов
	\item Избавление от недостижимых нетерминалов
	\item Преобразование остальных правил грамматики, добавление правил, пока все из них не будут иметь вид $A\rightarrow a$ или $A\rightarrow BC$.
\end{itemize}

Все эти преобразования не изменяют языка, описанного грамматикой. Доказательство не приводится. Большинство книг по теории языков обсуждают такие преобразования глубже, в том числе и доказательства. См. например [Books 1979].\\

\sss{Избавление от $\varepsilon$-правил}
Представьте, что мы имеем грамматику \textit{G}, включающую $\varepsilon$-продукцию $A\rightarrow
 \varepsilon$, от которой необходимо избавиться. Мы не можем просто удалить правило, так как это изменит язык, описываемый нетерминалом \textit{A}, а также язык, описываеммый всей грамматикой \textit{G} в целом. Значит нужно что-то сделать с правыми частями продукций, в которых присутствует \textit{A}. Всякий раз, когда символ \textit{A} встретится в продукции $B\rightarrow \alpha A\beta$, мы заменим его на два других: $B\rightarrow \alpha A^{'} \beta$, где $A^{'}$ это новый нетерминал, для которого мы добавим продукции чуть позже (это будут непустые продукции \textit{A}), а $B\rightarrow \alpha \beta$ служит для случая, когда \textit{A} выводит $\varepsilon$ в продукции $B\rightarrow \alpha A\beta$. Обратите внимание, что в вышеприведённых продукциях $\alpha$ и $\beta$ могут вновь иметь \textit{A}. В этом случае, каждое новое правило должно заменяться таким же образом, до тех пор, пока все \textit{A} не будут удалены. Когда мы закончим, грамматика не будет иметь ни одной продукции \textit{A}.\\
	Каждое $\varepsilon$-правило должно быть преобразовано таким способом. Конечно, в течении этого процесса могут появиться новые $\varepsilon$-правила. Об этом не стоит забывать, так как преобразование делает все $\varepsilon$-правила явными. Вновь созданные $\varepsilon$-правила должны вновь быть обработаны. В конце концов, такой "`цикл"' не может продолжаться бесконечно, так как число нетерминалов, выводящих $\varepsilon$, конечно. Ни один из них не будет находиться в правой части.\\
	Следующий шаг в удалении $\varepsilon $-правил это добавление новых продукций для созданных нетерминалов. Если \textit{A} это нетерминал, для которого было создано $A^{'}$, мы добавим продукцию $A^{'} \rightarrow \alpha $ для всех не-$\varepsilon $ правил $A \rightarrow \alpha $. Так как все $\varepsilon $-правила теперь находятся в явном виде, мы можем быть уверены, что продукция не выводит $\varepsilon$ ни прямо, ни косвенно. Может возникнуть проблема, если для \textit{A} не будет иметься не-$\varepsilon$ правил. В этом случае, \textit{A} всего лишь выводит $\varepsilon$, так что мы удалим все продукции $A^{'}$.\\
	Все это приводит к грамматике, которая вновь имеет $\varepsilon$-правила. Тем не менее, все нетерминалы имею правую часть без $\varepsilon$. Они только что были тщательно удалены, поэтому эти нетерминалы не играют роли в выводе от стартового символа \textit{S}, за исключением самого \textit{S}. В частности, мы имеем $S\rightarrow \varepsilon$ тогда и только тогда, когда $\varepsilon$ является членом грамматики \textit{G}. Все другие нетерминалы с $\varepsilon$-продукциями могут быть свободно удалены. 
%????
К приведению грамматики к нужному виду вернёмся чуть позже. \\

\begin{figure}[h]
\HSp
\begin{tabular}{lcl}
\label{fig4.8}
%\begin{center}
%\hspace{3.5cm}
\GrT{$S$} & $\rightarrow $ & $L\ a\ M$\\
\GrT{$L$} & $\rightarrow $ & $L\ M$\\
\GrT{$L$} & $\rightarrow $ & $\varepsilon $\\
\GrT{$M$} & $\rightarrow $ & $M\ M$\\
\GrT{$M$} & $\rightarrow $ & $\varepsilon $\\
%\end{center}
\end{tabular}
\caption{Грамматика для проверки механизма избавления от $\varepsilon$-продукций}
\end{figure}

	Грамматика на рис.4.8 - прекрасный случай для проверки муханизма избавления от $\varepsilon$-продукций. Наш алгоритм преобразует эту грамматику в приведённую на рис.4.9. Она все ещё имеет $\varepsilon$-продукции, но они уничтожаются при избавлении от непроизводящих и $\backslash$или недостижимых нетерминальных символов. Избавление от всего этого оставит всего одно правило: $S\rightarrow a$. На рис.4.10 изображена уже наша преобразованная грамматика. Обратите внимание, что две продукции, производящие $\varepsilon$, \textbf{Empty} и  \textbf{Scale} все ещё существуют, но уже не используются.\\

\begin{figure}[h]
\HSp
\begin{tabular}{lcl}
\label{fig4.9}
%\begin{center}
%\hspace{3.5cm}
\GrT{$S$} & 		$\rightarrow $ & $L^{'}\ a\ M^{'}\ |\ a\ M^{'}\ |\ L^{'}\ a\ |\ a$\\
\GrT{$L$} 	&		$\rightarrow $ & $L^{'}\ M^{'}\ |\ L^{'}\ |\ M^{'}\ |\ \varepsilon$\\
\GrT{$M$} & 		$\rightarrow $ & $M^{'}\ M^{'}\ |\ M^{'}\ |\ \varepsilon$\\
\GrT{$L^{'}$} & $\rightarrow $ & $L^{'}\ M^{'}\ |\ L^{'}\ |\ M^{'}$\\
\GrT{$M^{'}$} & $\rightarrow $ & $M^{'}\ M^{'}\ |\ M^{'}$\\
%\end{center}
\end{tabular}
\caption{После избавления от $\varepsilon$-продукций}
\end{figure}

\begin{figure}[h]
\HSp
\begin{tabular}{lcl}
\label{fig4.10}
%\begin{center}
%\hspace{3.5cm}
\GrT{$Number_s$} & 		$\rightarrow $ & $Interger\ |\ Real$\\
\GrT{$Integer$} & 		$\rightarrow $ & $Digit\ |\ Integer\ Digit$\\
\GrT{$Real$} &				$\rightarrow $ & $Integer\ Fraction\ Scale^{'}\ |\ Integer\ Fraction$\\
\GrT{$Fraction$} & 		$\rightarrow $ & $.\ Integer$\\
\GrT{$Scale^{'}$} & 	$\rightarrow $ & $e\ Sign\ Integer$\\
\GrT{$Scale$} &				$\rightarrow $ & $e\ Sign\ Integer\ |\ \varepsilon$\\
\GrT{$Empty$} & 			$\rightarrow $ & $\varepsilon$\\
%????:
\GrT{$Digit$} & 			$\rightarrow $ & $0|1|2|3|4|5|6|7|8|9$\\
\GrT{$Sign$} & 				$\rightarrow $ & $+\ |\ -$\\
%\end{center}
\end{tabular}
\caption{Грамматика после избавления от $\varepsilon$-продукций}
\end{figure}

%17.04.06
\sss{Избавление от цепных правил}
%\label{sec:ИзбавлениеОтПравилПеревода}
Далее мы избавимся от цепных (или сингулярных) правил, т.е. правил вида $A\rightarrow B$. Очень важно понять, что если $A\rightarrow B$ используется в выводе, то вывод должен продолжиться в какой-то момент правилом $B\rightarrow \alpha$. Поэтому, если мы имеем продукцию $A\rightarrow B$, а также набор правил для $B$
$$ B\rightarrow \alpha _1\ |\ \alpha _2\ |\ \cdots \ |\ \alpha _n$$
мы можем изменить правило $A\rightarrow B$ на 
$$ A\rightarrow \alpha _1\ |\ \alpha _2\ |\ \cdots \ |\ \alpha _n$$
Безусловно, мы можем создать другие цепные правила. В частности, повторяя этои действия, мы можем в какой-то момент опять получить $A\rightarrow B$. В этом случае, мы имеем бесконечно неоднозначную грамматику, т.к. $B$ выводит $B$. Это кажется неразрешимой трудностью, но на самом деле мы можем просто исключить такое правило. В результате мы сократим продукции вида $$ A\rightarrow B\rightarrow \cdots \rightarrow B\rightarrow \cdots$$
У нас остались продукции вида $A\rightarrow A$. Вообще, приятная особенность удаления $\varepsilon$-правил и цепных правил заключается в том, что грамматика уже не бесконечно неоднозначна.\\
	Удаление цепных правил в нашей $\varepsilon$-свободной грамматике приводит к картине, изображенной на рис.4.11.\\

\begin{figure}[h]
\HSp
\begin{tabular}{lcl}
\label{fig4.11}
%\hspace{3.5cm}
\GrT{$Number_s$} &		$\rightarrow $ & $0|1|2|3|4|5|6|7|8|9$\\
\GrT{$Number_s$} & 	$\rightarrow $ & $Integer\ Digit$\\
\GrT{$Number_s$} & 	$\rightarrow $& $Integer\ Fraction\ Scale^{'}\ |\ Integer\ Fraction$\\
\GrT{$Integer$} & 		$\rightarrow $ & $0|1|2|3|4|5|6|7|8|9$\\
\GrT{$Integer$} & 		$\rightarrow $ & $Integer\ Digit$\\
\GrT{$Real$} &				$\rightarrow $ & $Integer\ Fraction\ Scale^{'}\ |\ Integer\ Fraction$\\
\GrT{$Fraction$} & 		$\rightarrow $ & $.\ Integer$\\
\GrT{$Scale^{'}$} & 	$\rightarrow $ & $e\ Sign\ Integer$\\
\GrT{$Scale$} 	&			$\rightarrow $ & $e\ Sign\ Integer\ |\ \varepsilon$\\
\GrT{$Empty$}  &			$\rightarrow $ & $\varepsilon$\\
%????:7
\GrT{$Digit$}  &			$\rightarrow $ & $0|1|2|3|4|5|6|7|8|9$\\
\GrT{$Sign$} 	&			$\rightarrow $ & $+\ |\ -$\\
%\end{center}
\end{tabular}
\caption{Грамматика после избавления от цепных правил}
\end{figure}

\sss{Избавление от невыводящих нетерминалов}
%\label{sec:ИзбавлениеОтНевыводящихНетерминалов}
	\textit{Невыводящими} или \textit{непроизводящими} называют нетерминалы, не имеющие терминального вывода. Кажая сентенциальная форма, которая может быть выведена из такого нетерминала, будет содержать лишь нетерминалы. Это не очень хорошие новости для нашей грамматики. Вообще, "`правильные"' грамматики таких нетерминалов не имеют. Тем не менее, для проверки на "`правильность"', мы должны иметь возможность определить, какие нетерминалы \textit{имеют} терминальный вывод.\\
	Чтобы определить, какие нетерминалы имеют терминальный вывод, мы будем основываться на факте, что нетерминал имеет терминальный вывод тогда и только тогда, когда его правая часть содержит символы только с терминальными выводами. Безусловно, сами терминалы имеют терминальный вывод. Будем действовать следующим образом: сначала отметим нетерминалы, имеющие только терминальные символы в правой части. Они, естественно, имеют терминальный вывод. Далее, мы отметим нетерминалы, содержащие справа как терминалы, так и уже отмеченные нетерминалы. Они тоже имеют нетерминальный вывод. Теперь повторим эти шаги до тех пор, пока нечего будет отмечать.\\
	
	Все остальные невыделенные (неотмеченные) нетерминалы будут являться непроизводящими. Мы удалим все правила, имеющие невыделенный нетерминал в левой и правой частях. Этот процесс не удалит все правила выделенного нетерминала, т.к. должно сущестовать хотя бы одно правило, с правой частью только из терминалов или отмеченных нетерминалов. В противном случае, мы удалим все продукции, включая начальный символ, а значит грамматика будет описывать пустой язык.\\
	Наша числовая грамматика не имеет непроизводящих нетерминалов, поэтому она не претерпит изменений.\\
	
\sss{Избавление от недостижимых нетерминалов}
\textit{Достижимым} (или \textit{выводимым}) называют такой нетерминал, если существует хотя бы одна сентенциальная форма, выводимая из начального символа, в которой такой нетерминал содержится. Например, нетерминал $A$ достижим, если $S\stackrel{*}{\rightarrow \alpha A \beta}$ для какого-либо $\alpha$ и $\beta$. Нетерминал называют \textit{недостижимым} (или \textit{недоступным}), если он недостижим\footnote{Тавтология автора - Прим.пер.}. Также, как и невыводящие нетерминалы, недостижимые нетерминалы не существуют в "`правильных"' грамматиках. Тем не менее, они могут возникнуть в преобразованиях, которые мы видели выше, так что мы должны уметь находить их чтобы ещё раз "`очистить"' грамматику.\\
	Мы искали невыводящие нетерминалы с помошью нахождения "`выводящих"'. Точно так же, мы найдём недостижимые нетерминалы с помощью нахождения достижимых. Для этого будем действовать следующим образом: сначала отметим начальный символ, так как он достижим.
%стр 98
Далее, отмечая каждый раз другой неотмеченный нетерминал, отметим также все нетерминалы в любой из его правых частей. По окончании этого процесса, все неотмеченные нетерминалы являются недоступными и их продукции могут быть удалены. Они не присутствуют ни в одной из правых частей доступных нетерминалов, иначе они бы были отмечены.\\
	Интересно заметить, что удаление недоступных нетерминалов не вводит очередных невыводящих нетерминалов. Тем не менее, удаление сначала недоступных, а затем невыводящих нетерминалов может создать грамматику вновь с недоступными нетерминалами. Поиск соответствующего примера остаётся в качестве задания читателю.\\
	В нашей числовой грамматике из примера, нетерминалы $Real$, $Scale$, $Empty$ являются недостижимыми, что приводит, после их удаления, к картине, отраженной на рис. 4.12.\\
\begin{figure}[h]
\HSp
\begin{tabular}{lcl}
\label{fig4.12}
%\begin{center}
%\hspace{3.5cm}
\GrT{$Number_s$} 	&	$\rightarrow$  & $0|1|2|3|4|5|6|7|8|9$\\
\GrT{$Number_s$} 	&	$\rightarrow$  & $Integer\ Digit$\\
\GrT{$Number_s$} 	&	$\rightarrow $ & $Integer\ Fraction\ Scale^{'}\ |\ Integer\ Fraction$\\
\GrT{$Integer$}   &	$\rightarrow $ & $0|1|2|3|4|5|6|7|8|9$\\
\GrT{$Integer$} 	&	$\rightarrow $ & $Integer\ Digit$\\
\GrT{$Fraction$} 	&	$\rightarrow $ & $.\ Integer$\\
\GrT{$Scale^{'}$} & $\rightarrow $ & $e\ Sign\ Integer$\\
%????:
\GrT{$Digit$} 		&	$\rightarrow $ & $0|1|2|3|4|5|6|7|8|9$\\
\GrT{$Sign$}			&	$\rightarrow $ & $+\ |\ -$\\
%\end{center}
\end{tabular}
\caption{Грамматика после избавления от недостижимых нетерминалов}
\end{figure}

%название?	
\sss{Последний шаг к CNF}
После всех выполненных преобразований, мы имеем грамматику без $\varepsilon$-правил, без цепных правил, все её нетерминалы достижимы, и не осталось ни одного непроизводящего нетерминала. У нас остались всего два вида правил: правила вида $A\rightarrow a$, которые уже приведены в нужный вид, и правила вида $A\rightarrow X_1 X_2 \cdots X_m$, где $m\geq 2$. Для каждого терминала \textit{b} из такого правила, мы создаём новый нетерминал $T_b$ с единственным правилом $T_b \rightarrow b$, а затем заменяем каждое вхождение \textit{b} в правиле $A\rightarrow X_1 X_2 \cdots X_m$ c $T_b$.	Теперь, не в CNF находятся только продукции вида $A\rightarrow X_1 X_2 \cdots X_m$, где $m\geq 3$ и $X_i$ - нетерминал. Эти правила можно разделить:\\
$$A \rightarrow X_1 X_2 \cdots X_m$$
заменим на следующие два правила:\\
$$A \rightarrow A_1 X_3 \cdots X_m$$
$$A_1 \rightarrow X_1 X_2$$
где $A_1$ это новый нетерминал. Теперь мы заменили исходное правило двумя, одно из которых короче, а второе находится в CNF. Такое разделение может повторяться до тех пор, пока все части не будут находиться в CNF. Рис.4.13 приводит CNF нашей грамматики.

\begin{figure}[h]
\HSp
\begin{tabular}{lcl}
\label{fig4.13}
\GrT{$Number_s$} & 		$\rightarrow$ & $0|1|2|3|4|5|6|7|8|9$\\
\GrT{$Number_s$} & 		$\rightarrow$ & $Integer\ Digit$\\
\GrT{$Number_s$} & 		$\rightarrow$ & $N1\ Scale^{'}\ |\ Integer\ Fraction$\\
\GrT{$N1$} 			 &		$\rightarrow$ & $Integer\ Fraction$\\
\GrT{$Integer$}  &		$\rightarrow$ & $0|1|2|3|4|5|6|7|8|9$\\

\GrT{$Integer$}  &		$\rightarrow$ & $Integer\ Digit$\\
\GrT{$Fraction$} &		$\rightarrow$ & $T1\ Integer$\\
\GrT{$T1$}			 &		$\rightarrow$ & $.$\\
\GrT{$Scale^{'}$}&  	$\rightarrow$ & $N2\ Integer$\\
\GrT{$N2$} 			 &		$\rightarrow$ & $T2\ Sign$\\
\GrT{$T2$} 			 &		$\rightarrow$ & $e$\\
\GrT{$Digit$}		 &		$\rightarrow$ & $0|1|2|3|4|5|6|7|8|9$\\
\GrT{$Sign$} 		 &		$\rightarrow$ & $+\ |\ -$\\
\end{tabular}
\caption{Грамматика в CNF}
\end{figure}

%стр 99
\subsection{Вернёмся к примеру}
Давайте теперь посмотрим, как алгоритм CYK будет работать с нашей грамматикой, которую мы только что привели к CNF. Напомним, что на вход подаётся строка $32.5e+1$. Таблица обнаружения приведена на рис.4.14. Нижнюю строку видно непосредственно из грамматики; например, единственные нетерминалы, имеющие продукцию с $3$ в правой части это $Number$, $Integer$, $Digit$. Обратите внимание, что для каждого символа $a$ в предложении должен существовать хотя бы один нетерминал $A$ с правилом $A\rightarrow a$, иначе предложение невозможно вывести из грамматики.\\
	Другие строчки вычисляются как описано ранее. Вообще, существует всего два способа вычислить определённое $R_{s_{i,l}}$. Один из них заключается в проверке каждой правой части в грамматике, например, в проверке, выводит ли $N1\ Scale^{'}$ подстроку $2.5e$ (=$S_{2,4}$). Таблица обнаружения говорит, что:
	
\begin{itemize}
	\item $N1$ не член множеств $R_{s_{2,1}}$ или $R_{s_{2,2}}$
	\item $N1$ член $R_{s_{2,3}}$, но $Scale^{'}$ не член $R_{s_{5,1}}$
\end{itemize}
а значит ответ отрицателен. Применяя этот метод, мы должны таким образом проверить каждую правую часть, добавляя левую к $R_{s_{2,4}}$, если мы убедимся, что правая часть выводит $s_{2,4}$.\\
	Второй способ заключается в нахождении возможных правых частей из таблицы распознавания. Например, $R_{s_{2,4}}$ это множество нетерминалов, которые имеют правостороннюю часть $AB$, в которой:	
\begin{itemize}
	\item $A$ является членом $R_{s_{2,1}}$ и $B$ является членом $R_{s_{3,3}}$, или
	\item $A$ является членом $R_{s_{2,2}}$ и $B$ является членом $R_{s_{4,2}}$, или
	\item $A$ является членом $R_{s_{2,3}}$ и $B$ является членом $R_{s_{5,1}}$.
\end{itemize}
Это все возможные комбинации для $AB$: \textbf{N1\ T2} и \textbf{Number\ T2}. Теперь проверим все правила в грамматике на наличие их правой части в этом множестве. Если это так, то левая часть добавляется в $R_{s_{2,4}}$.\\

%18.04.06
\subsection{CYK-разбор с грамматикой в CNF}
%рис 4.14
Теперь мы знаем алгоритм определения того, принадлежит ли предложение языку или нет, и он гораздо быстрее простого метода. Большинство из нас, помимого всего прочего хочет знать, \textit{как} предложение выводится из грамматики. Если оно может выводиться несколькими способами, значит мы должны знать их все. Так как таблица распознавания содержит информацию о всех возможных выводах подстрок, она имеет всё нужное нам. К сожалению, эта таблица содержит так много информации, что скрывает много полезного. Таблица может содержать сведения о нетерминалах, выводящих подстроки, в то время как такие продукции не могут применяться в выводе входной последовательности из начального символа $S$. Например, в вышеприведённом примере $R_{s_{2,3}}$ содержит $N1$, но вывод $2.5$ из $N1$ не поможет нам в выводе $32.5e+1$ из $Number$.\\ 
	Ключ к решению лежит в том, что вывод должен начинаться от начального символа $S$. Можно довольно просто сделать первый шаг вывода входной строки $z$ длины \textit{n} имея грамматику и таблицу распознавания. Если $n=1$, то должно существовать правило $S\rightarrow z$. Если $n\geq 2$, то нужно проверить все правила $S\rightarrow AB$, где $A$ выводит первые $k$ символов предложения $z$, а $B$ все остальное. Значит, $A$  - член $R_{s_{1,k}}$, а $B$ - член
$R_{s_{k+1,n-k}}$, для какого-либо $k$. Должно существовать хотя бы одно такое правило, иначе $S$ не может вывести $z$.\\
	Теперь, для всех комбинаций $AB$ возникают схожие трудности: как $A$ вывести $s_{1,k}$, а $B$ вывести $s_{k+1,n-k}$? Это решается точно так же. Не имеет значения, какой нетерминал рассматривается первым. Просто, начиная с левого, получим левосторонний вывод, а начиная с правого - правосторонний вывод.\\
	Обратите внимание на возможность использования для этого Ангеро-подобного разборщика. Он не должен теперь создавать все возможные разделения, так как мы уже знаем, какие из них нам нужны.\\
	Давайте теперь найдём левостороннее порождение для того же примера и грамматики, используя таблицу обнаружения, приведённую на рис.4.14. Начнём с начального символа - $Number$. Наше предложение состоит из 7 символов, а это явно больше одного, так что нужно использовать одно из правил с правой частью вида $AB$. Правило $Integer\ Digit$ здесь не применить, так как единственный $Digit$, который может привести к выводу входного предложения является членом $R_{s_{7,1}}$, но $Integer$ не входит в множество $R_{s_{1,6}}$. Правило $Integer\ Fraction$ также нельзя использовать, так как $Fraction$ не может выводить оставшуюся часть предложения. Остаётся только продукция $Number\rightarrow N1\ Scale^{'}$ которую можно применить, так как $N1$ является членом $R_{s_{1,4}}$, а $Scale^{'}$ является членом $R_{s_{5,3}}$, так что $N1$ выводит $32.5$, а $Scale^{'}$ выводит $e+1$.\\
	Далее определим, как $N1$ выводит $32.5$. Существует лишь одно применимое правило: $N1\rightarrow Integer\ Fraction$ и его действительно можно применить, так как $Integer$ является членом $R_{s_{1,2}}$, а $Fraction$ является членом $R_{s_{3,2}}$, так что $Integer$ выводит $32$, а $Fraction$ выводит $.5$. В конце концов, получим следующую последовательность выводов:\\
%преобразованно
\begin{figure}[h]
\HSp
\label{fig4.14.2}
\begin{tabular}{lcl}%\hspace{3.5cm}
\GrT{$Number$}	&																$\rightarrow$\\
\GrT{$N1\ Scale^{'}$}& 													$\rightarrow$\\
\GrT{$Integer\ Fraction\ Scale^{'}$}& 					$\rightarrow$\\
\GrT{$Integer\ Digit\ Fraction\ Scale^{'}$}& 		$\rightarrow$\\
\GrT{$3\ Digit\ Fraction\ Scale^{'}$}& 					$\rightarrow$\\
\GrT{$3\ 2\ Fraction\ Scale^{'}$}& 							$\rightarrow$\\
\GrT{$3\ 2\ T1\ Integer\ Scale^{'}$}&					 	$\rightarrow$\\
\GrT{$3\ 2\ .\ Integer\ Scale^{'}$}& 						$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ Scale^{'}$}& 									$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ N2\ Integer$}& 								$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ T2\ Sign\ Integer$}& 					$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ e\ Sign\ Integer$}&					 	$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ e\ +\ Integer$}& 							$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ e\ +\ 1$}\\
\end{tabular}
%\end{figure}
\end{figure}
К сожалению, это не совсем то, что мы хотели. Эта последовательность вывода использовала грамматику, приведённую на рис.4.13, а не ту, что на рис.4.4 (с которой мы начинали).\\

%(проверить)
%19.04.06
%??? в названии
\subsection{Побочные эффекты преобразования}
Таблица обнаружения, приведённая на рис. 4.14, для грамматики с рис. 4.4, содержит практически всю информацию о нетерминалах, необходимую нам. Тем не менее, некоторых нетерминалов не хватает: $Scale$, $Real$, $Empty$. $Scale$ и $Empty$ были удалены, так как они стал недоступны после удаления $\epsilon$-правил. $Empty$ был бы удалён в любом случае, потому что он выводит пустую строку, а $Scale$ мы заменили на $Scale^{'}$. Обратите внимание, $Scale^{'}$ выводит в точности то же самое, что и $Scale$, за исключением пустой строки. Мы можем использовать этот факт, чтобы добавить больше информации в таблицу: к каждому существующему $Scale^{'}$ добавим $Scale$.\\
	Нетерминал $Real$ был удалён, так как он стал недоступным после удаления цепных правил. Теперь алгоритм CYK \textit{не требует} доступности всех нетерминалов в грамматике. Мы могли бы со спокойной душой оставить $Real$ и преобразовать его правила к CNF. Алгоритм CYK добавил бы его в таблицу распознавания когда бы это потребовалось. Вот првила $Real$, которые бы были добавлены в грамматику с рис. 4.13:\\
$$Real \rightarrow N1\ Scale^{'}\ |\ Integer\ Fraction$$
	Конечная таблица распознавания приведена на рис. 4.15. Мы добавили дополнительную строку внизу треугольника. Она олицетворяет нетерминалы, выводящие пустые строки. Можно считать, что эти нетерминалы находятся между любыми двумя смежными символами предложения, а также в его начале и конце. Множество $R_{s_{i,0}}$ отображает нетерминалы, способные находить только перед символом $z$, а $R_{s_{i,0}}$ отображает нетерминалы, способные находить только в конце предложения.\\
%рис 4.15 (треугольник)
	Теперь у нас есть готовая таблица распознавания, которая содержит всю нужную информацию для разбора предложения с помошью исходной грамматики. Снова вывод начинается от начального символа $S$. Если $A_1 A_2 \cdots A_m$ - правая часть $S$, то нужно узнать, какое правило может быть применено, т.е. выводит ли $A_1 A_2 \cdots A_m$ строку $s_{1,n}$. Начнём с $A_1$. Существует два варианта:
	
\begin{itemize}
	\item $A_1$ - терминал. В этом случае он должен быть первым символом $s_{1,n}$, иначе правило применить нельзя. Затем нужно проверить, выводит ли $A_2 \cdots A_m$ строку $s_{2,n-1}$.
	\item $A_1$ - нетерминал. В этом случае он должен быть членом множества $R_{s_{1,k}}$ для какого-либо $k$, иначе правило применить нельзя. Затем нужно проверить, выводит ли $A_2 \cdots A_m$ строку $s_{k+1,n-k}$. Если хотим получить все разборы, необходимо повторить это для всех $k$, таких, что $A_1$ является членом $R_{s_{1,k}}$. Обратите внимание, что нетерминал, выводящий пустую строку не создаст проблем, так как он является членом $R_{s_{i,0}}$ для всех $i$.
\end{itemize}

%20.04.06
	Мы определили, когда можно применить правило и какая часть выводит какую строку. Следующим этапом является определение как именно подстроки будут выводиться. Эта задача похожа на ту, с которой мы начали и решается точно так же. Этот процесс завершиться через какое-то время, очистив грамматику от циклов. Это, по сути, и есть разборщик Ангера, который знает наперёд, какое правило приведёт к успешному разбору.\\
	Давайте вернёмся к грамматике с рис. 4.4 и таблице определения с рис. 4.15, и рассмотрим, как это сработает для нашего входного предложения. Мы знаем, что $Number$ выводит $32.5e+1$, но хотим знать - как именно? Сперва зададим себе вопрос: можем ли мы использовать правило $Number \rightarrow Integer$? $Integer$ является членом $R_{s_{1,1}}$ и $R_{s_{1,2}}$, но это правило не может вывести отсальные символы предложения, так как $Integer$ является его последним символом. Возможно ли использовать првило $Number \rightarrow Real$? Да, так как $Real$ является членом $R_{s_{1,7}}$ и длина предложения равна семи. Поэтому, начнём наш вывод:\\
	$$ Number\ \rightarrow Real\ \rightarrow \cdots$$
%косяк с вопросом в конце формулы!!!
Теперь, мы должны ответить на идентичный вопрос и для нетерминала $Real$: возможно ли использовать правило $Real \rightarrow Integer\ Fraction\ Scale$. Да, $Integer$ является членом $R_{s_{1,1}}$, но мы не можем найти $Fraction$ ни в одном из множеств $R_{s_{2,k}}$. Тем не менее, $Integer$ также является членом $R_{s_{1,2}}$, а $Fraction$ является членом $R_{s_{3,2}}$. Далее, $Scale$ является членом $R_{s_{5,0}}$, но это не поможет, так как не оставит места в продукции для вывода остальной части строки. К счастью, $Scale$ является членом ещё одного множества $R_{s_{5,3}}$. Это в точности подходит для вывода окончания строки, так что мы применяем правило и продолжаем наш вывод:\\
$$Number \rightarrow Real \rightarrow Integer\ Fraction\ Scale \rightarrow \cdots $$
	Теперь предложение разделено на три части:\\
	%рис (таблица)
Оставим проверку того, что осталось лишь единственное порождение, читателю. Результат приведён на рис 4.16:

\begin{figure}[h]
\DHSp
\label{fig4.16own}
\begin{tabular}{lcl}%\hspace{3.5cm}
\GrT{$Number$} & 																$\rightarrow$\\
\GrT{$Integer\ Fraction\ Scale$}	&							$\rightarrow$\\
\GrT{$Integer\ Digit\ Fraction\ Scale$}& 				$\rightarrow$\\
\GrT{$Digit\ Digit\ Fraction\ Scale$}& 					$\rightarrow$\\
\GrT{$3\ Digit\ Fraction\ Scale$}& 							$\rightarrow$\\
\GrT{$3\ 2\ Fraction\ Scale$}& 									$\rightarrow$\\
\GrT{$3\ 2\ .\ Integer\ Scale$}& 								$\rightarrow$\\
\GrT{$3\ 2\ .\ Digit\ Scale$}& 									$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ Scale$}& 											$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ e\ Sign\ Integer$}& 					$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ e\ +\ Integer$}& 							$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ e\ +\ Digit$}& 								$\rightarrow$\\
\GrT{$3\ 2\ .\ 5\ e\ +\ 1$}
\end{tabular}
\caption{Конечный результат}
\end{figure}

%21.04.06
\subsection{Краткое резюме}
	Мы прошли огромный путь. Начиналось всё с построения таблицы распознавания по исходной грамматике. Затем мы поняли, что использование начальной грамматики со всеми её $\epsilon$-правилами и цепными правилами - довольно трудный процесс, но, конечно не безуспешный. Мы исправили грамматику и привели её к CNF. В этот момент она уже не содержала правил перевода и $\epsilon$-правил, поэтому алгорит построения таблицы распознавания стал гораздо проще. Ограничение правой части двумя символами также привело к упрощению и улучшению алгоритма. Шейл [CF 1976] показал, что эффективность зависит лишь от количества терминалов в правой части правил, не от их длины. Это легко понять, если представить, что на эффективность влияет количество "`разделений"' строки, которые сложно найти проверкой наличия вывода. Количество таких "`сложных разделений"' зависит лишь от количества нетерминалов в правой части. Так что, даже в плане производительности, CNF немного лучше.\\
	Недостатком такого превращения грамматики является отсутсвие в таблице распознавания некоторой, нужной для построения разделений согласно начальной грамматики, информации. В процессе перевода некоторые нетерминалы были исключены, так как стали непроизводящими. К счастью, недостающая информация может быть легко восстановлена. В конце коноцов, таблица распознавания стала практически такой же, как если бы мы построили её для начальной грамматики. Она содежит чуть больше информации о нетерминалах, которые были добавлены в процессе перевода. Более важно то, что таблица была получена более простым и гораздо более эффективным путём.\\
	
\subsection{Разбор схем}
	Алгоритм CYK известен также под названием \textit{разбор схем}\footnote{chart parsing- Прим.пер.}. Точнее, это не одно и то же, но оба метода имеют различные формы, т.е. некоторые из видов CYK-разбора являются идентичными некоторым видам разбора схем. Самое разительное отличие кроется в их реализации; концептуально оба алгоритма выполняют то же самое: они отыскивают  разбор все больших и больших подстрок.\\
	Схема, часто представленная в различных формах, это простая таблица распознавания! Рис. 4.16 показывает таблицу распознавания с рис. 4.14 в виде схемы: каждая дуга отображает нетерминал, выводящий ту часть предложения, которую она охватывает.\\
%рис 4.16.
	Различные варианты разбора схем рассматриваются и сравниваются в [NatLang 1987].
  
%всего 105 страниц.

